# CH.7 Lexical Scope

> **렉시컬  스코프**는 변수와 스코프 블록을 어디서 작성하는가에 따라 렉서가 확정한다.
> 쉽게 말해, 변수와 함수를 어디에 선언했는지에 따라 결정된다.

## 2.1 렉스타임

> 렉시컬 스코프는 렉싱 타임에 정의되는 스코프다.
> 
> 바꿔 말해, 렉시컬 스코프는 변수와 스코프 블록을 어디서 작성하는가에 기초해서 렉서가 코드를 처리할 때 확정한다.

```javascript
// 글로벌 스코프 (1)

function foo(a) { // 중간 스코프 foo() (2)
    var b = a * 2;
    
    function bar(c) { // 가장 안쪽의 스코프 bar() (3)
        // LHS, RHS 규칙에 따라 내부에서 바깥의 스코프로 검색해간다.
        // 단, 해당 확인자를 탐색해내면 탐색 중단.
        console.log(a, b, c)
    }
    
    bar(b * 3);
} 

foo(2); // 2, 4, 12
```

어떤 함수가 어디서 또는 어떻게 호출되는지 상관없이 **함수의 렉시컬 스코프는 함수가 선언된 위치**에 따라 결정된다.
## 2.2 렉시컬 속이기

렉시컬 스코프를 속이는 방법은 두 가지 방법이 있다.
- eval()
- with

하지만 렉시컬 스코프를 속이는 방법은 성능 저하를 일으킨다.

그 이유는 자바스크립트는 컴파일을 하면서 최적화를 한다고 했는데, 이 중 핵심적인 요소가 모든 변수와 함수 선언문을 파악하고 실행 과정에서 확인자 검색을 빠르게 하는 것이기 때문이다.

> 즉, 렉시컬을 속인다는 것은 컴파일 시 진행되었던 최적화의 의미가 사라지게 된다.
### 2.2.1 eval

- eval() 함수는 `문자열을 인자로 받아들여 문자열 내용을 코드처럼 처리`한다.

- 예제
    ```javascript
    function foo(str, a) {
    eval(str); // 'var b = 3' 문자열을 코드로 인식한다.
    console.log(a, b);
  }
  var b = 2; // 최상위 스코프지만 eval() 함수로 인해 이곳까지 탐색되지 않는다.
  foo("var b = 3;", 1) ;; // 1, 3
    ```
  > foo() 함수 안의 eval('var b = 3')이 코드로 인식 되므로 해당 스코프에 b가 생성되어 렉시컬 스코프가 수정되었다.

이 외의 `setTimeout()`,`setInterval()`, `new Function()` 로도 렉시컬 스코프를 수정할 수 있으나 성능 저하를 일으키므로 사용하지 말자.

### 2.2.2 with

- with는 `한 객체의 여러 속성을 참조할 때, 객체 참조를 매번 박복하기 않기 위해 사용하는 일종의 속기법`
  - 사용 예제
    ```javascript
    var obj = {
        a: 1,
        b: 2,
        c: 3,
    }
    
    // 매우 불편한 객체 참조법
    obj.a = 2;
    obj.b = 3;
    obj.c = 4;
    console.log(obj) // { a: 2, b: 3, c: 4 }
    
    // with를 활용한 객체 참조
    with (obj) {
        a = 3;
        b = 4;
        c = 5;
    }
    console.log(obj) // { a: 3, b: 4, b: 5 }
      ```

- with로 렉시컬 속이기
  ```javascript
  function foo(object) {
      // 독립된 렉시컬 스코프
      with (object) {
          a = 2; // object 객체의 a 속성의 값에 2를 대입해라.
      }
  }
  
  var o1 = {
      a: 3
  } // o1 = { a: 3 }
  
  var o2 = {
      b: 100
  } // o2 = { b: 100 }
  
  foo(o1);
  console.log( o1.a ) // 2
  
  foo(o2);
  console.log( o2.a ) // undefined
  console.log( a ) // 2 --> 가슴이 웅장해지는 동작..?
  ```

> 어떻게 이런 일이 발생할까?

`with`문은 속서을 가진 객체를 받고 **하나의 독립된 렉시컬 스코프로 취급한다.**

```javascript
// 독립된 렉시컬 스코프
with(object) {
    // object의 확인자 a = 2 라는 의미로 LHS 참조를 한다.
    // 만약, 해당자가 존재하지 않으면 LHS의 오류 방식으로 동작한다.
    // 즉, 최상위 스코프까지 a라는 확인자를 찾는데 존재하지 않으면, 최상위 스코프에 const a = 2라고 만들어주는 것.
    a = 2;
}
```

> "use strict" 를 사용하면 eval()과 with 사용이 제한된다. 하지만 애초에 사용하지 않는 것을 권장한다.

### 2.2.3 성능

> 런타임에서 스코프를 수정하거나 새로운 렉시컬 스코프를 만드는 것으로 `eval()`과 `with`가 있는데, 이는 원래 작성된 렉시컬 스코프를 속이는 행위다.
> 
> 컴파일 단계에서 상당수의 최적화가 이루어지는데, 이 안에는 렉시컬 스코프를 정의한다. 그러므로 코드 실행단계에서 렉시컬을 속이는 것은 최적화의 의미가 사라진다.
> 
> 즉, `eval()`또는 `with`를 사용했다는 사살 하나만으로 코드가 보다 느리게 동작한다.
> 
> 그러므로 렉시컬 스코프를 수정하는 좋은 방법은 코드를 수정하는 것이다.